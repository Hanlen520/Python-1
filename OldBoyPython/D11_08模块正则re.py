#!/bin/usr/env python3
# -*- coding: utf-8 -*-
# --------------------------------------
# ProjectName: MySpace
# Author: crisimple
# CreateTime: 2019/1/23 23:58
# FileName: D11_08模块正则re.py
# Description:
#           就其本质而言，正则表达式(或re)是一种小型的、高度专业化的编程语言，它内嵌在Python中
#       并通过re模块来实现，正则表达式模式被编译成一系列的字节码，然后由用C编写的匹配引擎执行。
#  正则的作用：可以进行模糊匹配
# Question:
# --------------------------------------

<<<<<<< HEAD


=======
import re

string1 = "Hello World"

# 字符串匹配
# 字符串提供的方法是一种完全匹配，正则提供的是模糊匹配
# string1.find()
# , flags= 可以修改匹配规则
res1 = re.findall("w\w{2}l", "Hello world")
print(res1)

# 1.元字符重复匹配正则实现：
# . ==通配符  只能代指任意一个字符（除了换行符之外） 等价于：{1}
# ^ ==开始匹配符，以什么开始匹配
# $ ==结束匹配符，以什么结束匹配等价于：
# * ==重复匹配符[0, +∞]，可以匹配多个元字符等价于：  等价于：{0， +∞}
# + ==重复匹配符[1, +∞]，可以匹配多个元字符等价于：  等价于：{1, +∞}
# ？ ==重复匹配符[0, 1]，可以匹配多个元字符等价于：  等价于：{0, 1}
# {a, b} ==贪婪匹配任意字符a~b次


# 2.字符集[]：取消元字符的特殊功能(除：\ ^ -)
res2 = re.findall('[w, .]', 'wd.')
print(res2)
# ^放在[]为取反的意思
res3 = re.findall('[^x]', 'yzghxmo')
print(res3)
# \
# \D 匹配任何非数字字符，它相当于类[^0~9]
# \s 匹配任何空白字符，它相当于类[ \t \n \r \f \v]
# \S 匹配任何非空白字符，它相当于类[^ \t \n \r \f \v]
# \w 匹配任何字母数字字符，它相当于类[a-zA-Z0-9]
# \W 匹配任何非字母数字字符，它相当于类[^a-zA-Z0-9]
# \b 匹配与特殊字符的边界


# 3. re.search()返回一个匹配的对象

# 4. ()分组
res4 = re.findall('(as)+', "fdassaasdfg")
print("res4: ", res4)


# 二、正则表达式的方法：
# 1. findall()      所有结果都返回到一个列表里
# 2. search()       返回一个对象(object)，对象可以调用group方法返回结果
# 3. match()        只在字符串开始匹配, 返回第一个匹配到的对象
# 4. split([k, s])  分别通过[k, s]进行字符串分割
# 5. sub('t..n', 'b......b', 'string') 位置二将位置与位置三匹配的地方进行替换
# 6. compile()      规则重复使用是就要用这种方法进行规则的编译, 然后用返回的对象进行1-5方法的调用
obj = re.compile("\.com")
obj.findall()
obj.search()
obj.match()
obj.split()
obj.sub()
>>>>>>> 98747c637d2c254935870626558111125a654386






